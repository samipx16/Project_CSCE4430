#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <cstdlib>
using namespace std;

// Define token types
enum TokenType { INTEGER, OPERATOR, END_OF_FILE };

struct Token {
    TokenType type;
    string lexeme;
};

// Global vector to hold tokens and a token index for the parser.
vector<Token> tokens;
int tokenIndex = 0;

// Get the next token and peek at the current token.
Token getNextToken() {
    if (tokenIndex < tokens.size())
        return tokens[tokenIndex++];
    return {END_OF_FILE, ""};
}

Token peekToken() {
    if (tokenIndex < tokens.size())
        return tokens[tokenIndex];
    return {END_OF_FILE, ""};
}

// Define the AST node structure.
struct ASTNode {
    string label;
    ASTNode* left;
    ASTNode* right;
    ASTNode(string lbl) : label(lbl), left(nullptr), right(nullptr) {}
};

// Forward declarations for recursive descent functions.
ASTNode* expression();
ASTNode* expressionSuffix(ASTNode* left);
ASTNode* term();
ASTNode* termSuffix(ASTNode* left);
ASTNode* factor();

// <expression> -> <term> <expression_suffix>
ASTNode* expression() {
    ASTNode* t = term();
    return expressionSuffix(t);
}

// <expression_suffix> -> + <term> <expression_suffix> | - <term> <expression_suffix> | ε
ASTNode* expressionSuffix(ASTNode* left) {
    Token tk = peekToken();
    if (tk.type == OPERATOR && (tk.lexeme == "+" || tk.lexeme == "-")) {
        getNextToken(); // Consume the operator.
        ASTNode* rightTerm = term();
        // Create an operator node (either "Add" or "Subtract")
        string opLabel = (tk.lexeme == "+") ? "Add" : "Subtract";
        ASTNode* opNode = new ASTNode(opLabel);
        opNode->left = left;
        opNode->right = rightTerm;
        // Recurse to handle left-associativity.
        return expressionSuffix(opNode);
    }
    return left;
}

// <term> -> <factor> <term_suffix>
ASTNode* term() {
    ASTNode* f = factor();
    return termSuffix(f);
}

// <term_suffix> -> * <factor> <term_suffix> | / <factor> <term_suffix> | ε
ASTNode* termSuffix(ASTNode* left) {
    Token tk = peekToken();
    if (tk.type == OPERATOR && (tk.lexeme == "*" || tk.lexeme == "/")) {
        getNextToken(); // Consume the operator.
        ASTNode* rightFactor = factor();
        string opLabel = (tk.lexeme == "*") ? "Multiply" : "Divide";
        ASTNode* opNode = new ASTNode(opLabel);
        opNode->left = left;
        opNode->right = rightFactor;
        return termSuffix(opNode);
    }
    return left;
}

// <factor> -> ( <expression> ) | <integer>
ASTNode* factor() {
    Token tk = peekToken();
    if (tk.type == OPERATOR && tk.lexeme == "(") {
        getNextToken(); // Consume '('.
        ASTNode* expr = expression();
        Token next = getNextToken();
        if (next.type != OPERATOR || next.lexeme != ")") {
            cerr << "Syntax error: expected ')'" << endl;
            exit(1);
        }
        return expr;
    } else if (tk.type == INTEGER) {
        getNextToken(); // Consume integer.
        // Create an AST leaf node for the integer.
        ASTNode* node = new ASTNode(tk.lexeme + " (int)");
        return node;
    } else {
        cerr << "Syntax error: unexpected token '" << tk.lexeme << "'" << endl;
        exit(1);
    }
}

// A helper function to print the AST in a tree-like structure.
void printAST(ASTNode* node, int indent = 0) {
    if (!node) return;
    for (int i = 0; i < indent; i++)
        cout << "    ";
    cout << node->label << endl;
    printAST(node->left, indent + 1);
    printAST(node->right, indent + 1);
}

int main() {
    // Read the tokens generated by the lexer from tokens.txt.
    ifstream infile("tokens.txt");
    if (!infile) {
        cerr << "Error opening tokens.txt" << endl;
        return 1;
    }
    string line;
    while(getline(infile, line)) {
        istringstream iss(line);
        string lexeme, tokenStr;
        if (getline(iss, lexeme, ',') && getline(iss, tokenStr)) {
            Token t;
            t.lexeme = lexeme;
            if (tokenStr == "integer")
                t.type = INTEGER;
            else if (tokenStr == "operator")
                t.type = OPERATOR;
            tokens.push_back(t);
        }
    }
    infile.close();

    // Parse the tokens to build the AST.
    ASTNode* ast = expression();

    // Check for extra tokens after parsing.
    if (tokenIndex < tokens.size()){
        cerr << "Syntax error: extra tokens remaining." << endl;
        return 1;
    }

    cout << "Abstract Syntax Tree:" << endl;
    printAST(ast);
    return 0;
}
